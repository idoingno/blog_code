---
title: 链表
autoGroup-2: 数据结构与算法
---

> 一个经典的链表应用场景，那就是 `LRU` 缓存淘汰算法
> 
> 缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等。
> 
> 缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：**先进先出策略 FIFO（First In，First Out）**、**最少使用策略 LFU（Least Frequently Used）**、**最近最少使用策略 LRU（Least Recently Used）**。

## 链表结构

对比一下 链表和数组的数据结构

### 底层的存储结构

数组需要一块连续的内存空间来存储，对内存的要求比较高。

链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用

> 空间换时间：对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。

![](/imgs/js/L3.webp)

### 单链表

内存块称为链表的“结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把这个记录下个结点地址的指针叫作后继指针 next。

![](/imgs/js/L4.webp)

习惯性地把第一个结点叫作头结点，把最后一个结点叫作尾结点。其中，头结点用来记录链表的基地址。有了它，就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个空地址 `NULL`，表示这是链表上最后一个结点。

插入：在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 <common-latexDisplay> O(n) </common-latexDisplay>。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。

![](/imgs/js/L5.webp)

> 从图中可以看出，针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 <common-latexDisplay> O(1) </common-latexDisplay>

访问低效：因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。链表随机访问的性能没有数组好，需要 <common-latexDisplay> O(n) </common-latexDisplay> 的时间复杂度。

### 循环链表

循环链表是一种特殊的单链表。它跟单链表唯一的区别就在尾结点。单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。

![](/imgs/js/L6.webp)

和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。

### 双向链表

单向链表只有一个方向，结点只有一个后继指针 `next` 指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 `next` 指向后面的结点，还有一个前驱指针 `prev` 指向前面的结点。

![](/imgs/js/L7.webp)

- 双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。
- 如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。
- 虽然两个指针比较浪费存储空间，但可以支持双向遍历

### 双向循环链表

![](/imgs/js/L8.webp)

## 数组和链表性能比较

![](/imgs/js/L9.webp)

数组简单易用，在实现上使用的是连续的内存空间，可以借助 `CPU` 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 `CPU` 缓存不友好，没办法有效预读。

数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容。

如果代码对内存的使用非常苛刻，那数组就更适合。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 `Java` 语言，就有可能会导致频繁的 `GC（Garbage Collection，垃圾回收）`。

## LRU 缓存淘汰算法

维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。

2. 如果此数据没有在缓存链表中，又可以分为两种情况：
    - 如果此时缓存未满，则将此结点直接插入到链表的头部；
    - 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。

> (概括下： 使用定长链表来保存所有缓存的值，并且最老的值放在链表最后面 当访问的值在链表中时： 将找到链表中值将其删除，并重新在链表头添加该值（保证链表中 数值的顺序是从新到旧） 当访问的值不在链表中时： 当链表已满：删除链表最后一个值，将要添加的值放在链表头 当链表未满：直接在链表头添加)


## 写链表代码技巧

### 技巧一：理解指针或引用的含义

有些语言有“指针”的概念，比如 C 语言；有些语言没有指针，取而代之的是“引用”，比如 Java、Python。不管是“指针”还是“引用”，实际上，它们的意思都是一样的，都是存储所指对象的内存地址。

将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。

- 经常会有这样的代码：`p->next=q`。这行代码是说，`p` 结点中的 `next` 指针存储了 `q` 结点的内存地址。
- 写链表代码经常会用到的：`p->next=p->next->next`。这行代码表示，`p` 结点的 `next` 指针存储了 `p` 结点的下下一个结点的内存地址。

### 技巧二：警惕指针丢失和内存泄漏

插入结点时，一定要注意操作的顺序

![](/imgs/js/L10.webp)

如图所示，我们希望在结点 a 和相邻的结点 b 之间插入结点 x，假设当前指针 p 指向结点 a。

```C
// 这块代码就会发生指针丢失和内存泄露
p->next = x;  // 将p的next指针指向x结点；
x->next = p->next;  // 将x的结点的next指针指向b结点；

// p->next 指针在完成第一步操作之后，已经不再指向结点 b 了，而是指向结点 x。
// 第 2 行代码相当于将 x 赋值给 x->next，自己指向自己。因此，整个链表也就断成了两半，从结点 b 往后的所有结点都无法访问到了。

// 要先将结点 x 的 next 指针指向结点 b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏。
// 这里只需要把两行代码顺序颠倒一下就行
```

删除链表结点时，也一定要记得手动释放内存空间，否则，也会出现内存泄漏的问题。当然，对于像 `Java` 这种虚拟机自动管理内存的编程语言来说，就不需要考虑这么多了。

### 技巧三：利用哨兵简化实现难度

```C
// 如果我们在结点 p 后面插入一个新的结点，只需要下面两行代码就可以搞定。

new_node->next = p->next;
p->next = new_node;

// 但是，当要向一个空链表中插入第一个结点，刚刚的逻辑就不能用了。我们需要进行下面这样的特殊处理，其中 head 表示链表的头结点。
if (head == null) {
  head = new_node;
}

// 如果要删除结点 p 的后继结点，我们只需要一行代码就可以搞定。
p->next = p->next->next;

// 但是，如果要删除链表中的最后一个结点，前面的删除代码就不 work 了
if (head->next == null) {
   head = null;
}
```

针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。

表示一个空链表: `head=null` 表示链表中没有结点了。其中 `head` 表示头结点指针，指向链表中的第一个结点。

如果引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫**带头链表**。相反，没有哨兵结点的链表就叫作**不带头链表**。

![](/imgs/js/L11.webp)

哨兵结点是不存储数据的。因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了。

### 技巧四：重点留意边界条件处理

软件开发中，代码在一些边界或者异常情况下，最容易产生 `Bug`。链表代码也不例外。要实现没有 `Bug` 的链表代码，一定要在编写的过程中以及编写完成之后，检查边界条件是否考虑全面，以及代码在边界条件下是否能正确运行。

经常用来检查链表代码是否正确的边界条件有这样几个：
- 如果链表为空时，代码是否能正常工作？
- 如果链表只包含一个结点时，代码是否能正常工作？
- 如果链表只包含两个结点时，代码是否能正常工作？
- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

### 技巧五：举例画图，辅助思考

对于稍微复杂的链表操作，比如前面提到的单链表反转，指针一会儿指这，一会儿指那，一会儿就被绕晕了。所以这个时候就要使用大招了，**举例法和画图法**。

![](/imgs/js/L12.webp)

## Tips

精选了 5 个常见的链表操作用于练习
- [ 单链表反转 - ](/fontend/Js/js-basic-algorithm/#链表反转) 
- [ 链表中环的检测 - ](/fontend/Js/js-basic-algorithm/#环形链表)
- [ 两个有序的链表合并 - ](/fontend/Js/js-basic-algorithm/#合并有序链表)
- [ 删除链表倒数第N个结点 - ](/fontend/Js/js-basic-algorithm/#删除链表的倒数第n个结点)
- [ 求链表的中间结点 - ](/fontend/Js/js-basic-algorithm/#求链表的中间结点)