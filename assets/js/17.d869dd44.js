(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{616:function(t,a,s){"use strict";s.r(a);var n=s(14),r=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"dom-diff"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dom-diff"}},[t._v("#")]),t._v(" Dom diff")]),t._v(" "),s("p",[t._v("通过"),s("code",[t._v("JS")]),t._v("层面的计算，返回一个 patch 对象，即补丁对象，在通过特定的操作解析"),s("code",[t._v("patch")]),t._v("对象，完成页面的重新渲染。")]),t._v(" "),s("blockquote",[s("p",[t._v("完全对比方案 时间复杂度为 O(n³)")])]),t._v(" "),s("p",[t._v("关于 O(n³) 的由来。由于左树中任意节点都可能出现在右树，所以必须在对左树深度遍历的同时，对右树进行深度遍历，找到每个节点的对应关系，这里的时间复杂度是 O(n²)，之后需要对树的各节点进行增删移的操作，这个过程简单可以理解为加了一层遍历循环，因此再乘一个 n。")]),t._v(" "),s("p",[s("img",{staticClass:"lazy",attrs:{alt:"","data-src":"/frontend-apprenticeship/imgs/0210302175705.jpg",loading:"lazy"}})]),t._v(" "),s("h2",{attrs:{id:"vue-的-dom-diff"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-的-dom-diff"}},[t._v("#")]),t._v(" Vue 的 Dom diff")]),t._v(" "),s("p",[t._v("同层比较 时间复杂度为 O(n)")]),t._v(" "),s("ol",[s("li",[t._v("尽量保证不要发生 dom 位移, 左右夹击跳过不变的")]),t._v(" "),s("li",[t._v("找到"),s("strong",[t._v("最长连续子串")]),t._v("保持不动，移动其他元素")])]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 动态规划，设 dp(i) 为以第 i 个字符串结尾的最长连续子串长度，一次 O(n) 循环即可。")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("dp")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" num"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" num"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("dp")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n")])])]),s("h2",{attrs:{id:"react-的-dom-diff"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react-的-dom-diff"}},[t._v("#")]),t._v(" React 的 Dom diff")]),t._v(" "),s("p",[t._v("同层比较 时间复杂度为 O(n)")]),t._v(" "),s("ol",[s("li",[t._v("React 采用了 "),s("strong",[t._v("仅右移策略")]),t._v(", 对元素发生的位置变化，只会将其移动到右边，那么右边移完了，其他位置也就有序了")]),t._v(" "),s("li",[t._v("在大部分从左往右移的业务场景中，得到了较好的性能")])])])}),[],!1,null,null,null);a.default=r.exports}}]);